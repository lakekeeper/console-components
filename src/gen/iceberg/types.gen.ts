// This file is auto-generated by @hey-api/openapi-ts

/**
 * JSON error payload returned in a response with further details on the error
 */
export type ErrorModel = {
  /**
   * Human-readable error message
   */
  message: string;
  /**
   * Internal type definition of the error
   */
  type: string;
  /**
   * HTTP response code
   */
  code: number;
  stack?: Array<string>;
};

/**
 * Server-provided configuration for the catalog.
 */
export type CatalogConfig = {
  /**
   * Properties that should be used to override client configuration; applied after defaults and client configuration.
   */
  overrides: {
    [key: string]: string;
  };
  /**
   * Properties that should be used as default configuration; applied before client configuration.
   */
  defaults: {
    [key: string]: string;
  };
  /**
   * A list of endpoints that the server supports. The format of each endpoint must be "<HTTP verb> <resource path from OpenAPI REST spec>". The HTTP verb and the resource path must be separated by a space character.
   */
  endpoints?: Array<string>;
};

export type CreateNamespaceRequest = {
  namespace: Namespace;
  /**
   * Configured string to string map of properties for the namespace
   */
  properties?: {
    [key: string]: string;
  };
};

export type UpdateNamespacePropertiesRequest = {
  removals?: Array<string>;
  updates?: {
    [key: string]: string;
  };
};

export type RenameTableRequest = {
  source: TableIdentifier;
  destination: TableIdentifier;
};

/**
 * Reference to one or more levels of a namespace
 */
export type Namespace = Array<string>;

/**
 * An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
 * Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
 * Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
 * Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
 * Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
 */
export type PageToken = string;

export type TableIdentifier = {
  namespace: Namespace;
  name: string;
};

export type PrimitiveType = string;

export type StructField = {
  id: number;
  name: string;
  type: Type;
  required: boolean;
  doc?: string;
  'initial-default'?: PrimitiveTypeValue;
  'write-default'?: PrimitiveTypeValue;
};

export type StructType = {
  type: 'struct';
  fields: Array<StructField>;
};

export type ListType = {
  type: 'list';
  'element-id': number;
  element: Type;
  'element-required': boolean;
};

export type MapType = {
  type: 'map';
  'key-id': number;
  key: Type;
  'value-id': number;
  value: Type;
  'value-required': boolean;
};

export type Type = PrimitiveType | StructType | ListType | MapType;

export type SchemaReadable = StructType & {
  readonly 'schema-id'?: number;
  'identifier-field-ids'?: Array<number>;
};

export type SchemaWritable = StructType & {
  'identifier-field-ids'?: Array<number>;
};

export type Expression =
  | TrueExpression
  | FalseExpression
  | AndOrExpression
  | NotExpression
  | SetExpression
  | LiteralExpression
  | UnaryExpression;

export type ExpressionType = string;

export type TrueExpression = {
  type: ExpressionType;
};

export type FalseExpression = {
  type: ExpressionType;
};

export type AndOrExpression = {
  type: ExpressionType;
  left: Expression;
  right: Expression;
};

export type NotExpression = {
  type: ExpressionType;
  child: Expression;
};

export type UnaryExpression = {
  type: ExpressionType;
  term: Term;
  value: {
    [key: string]: unknown;
  };
};

export type LiteralExpression = {
  type: ExpressionType;
  term: Term;
  value: {
    [key: string]: unknown;
  };
};

export type SetExpression = {
  type: ExpressionType;
  term: Term;
  values: Array<{
    [key: string]: unknown;
  }>;
};

export type Term = Reference | TransformTerm;

export type Reference = string;

export type TransformTerm = {
  type: 'transform';
  transform: Transform;
  term: Reference;
};

export type Transform = string;

export type PartitionField = {
  'field-id'?: number;
  'source-id': number;
  name: string;
  transform: Transform;
};

export type PartitionSpecReadable = {
  readonly 'spec-id'?: number;
  fields: Array<PartitionField>;
};

export type PartitionSpecWritable = {
  fields: Array<PartitionField>;
};

export type SortDirection = 'asc' | 'desc';

export type NullOrder = 'nulls-first' | 'nulls-last';

export type SortField = {
  'source-id': number;
  transform: Transform;
  direction: SortDirection;
  'null-order': NullOrder;
};

export type SortOrderReadable = {
  readonly 'order-id': number;
  fields: Array<SortField>;
};

export type SortOrderWritable = {
  fields: Array<SortField>;
};

export type EncryptedKey = {
  'key-id': string;
  'encrypted-key-metadata': string;
  'encrypted-by-id'?: string;
  properties?: {
    [key: string]: string;
  };
};

export type Snapshot = {
  'snapshot-id': number;
  'parent-snapshot-id'?: number;
  'sequence-number'?: number;
  'timestamp-ms': number;
  /**
   * Location of the snapshot's manifest list file
   */
  'manifest-list': string;
  /**
   * The first _row_id assigned to the first row in the first data file in the first manifest
   */
  'first-row-id'?: number;
  /**
   * The upper bound of the number of rows with assigned row IDs
   */
  'added-rows'?: number;
  summary: {
    operation: 'append' | 'replace' | 'overwrite' | 'delete';
    [key: string]: string | ('append' | 'replace' | 'overwrite' | 'delete');
  };
  'schema-id'?: number;
};

export type SnapshotReference = {
  type: 'tag' | 'branch';
  'snapshot-id': number;
  'max-ref-age-ms'?: number;
  'max-snapshot-age-ms'?: number;
  'min-snapshots-to-keep'?: number;
};

export type SnapshotReferences = {
  [key: string]: SnapshotReference;
};

export type SnapshotLog = Array<{
  'snapshot-id': number;
  'timestamp-ms': number;
}>;

export type MetadataLog = Array<{
  'metadata-file': string;
  'timestamp-ms': number;
}>;

export type TableMetadataReadable = {
  'format-version': number;
  'table-uuid': string;
  location?: string;
  'last-updated-ms'?: number;
  /**
   * A long higher than all assigned row IDs; the next snapshot's first-row-id.
   */
  'next-row-id'?: number;
  properties?: {
    [key: string]: string;
  };
  schemas?: Array<SchemaReadable>;
  'current-schema-id'?: number;
  'last-column-id'?: number;
  'partition-specs'?: Array<PartitionSpecReadable>;
  'default-spec-id'?: number;
  'last-partition-id'?: number;
  'sort-orders'?: Array<SortOrderReadable>;
  'default-sort-order-id'?: number;
  'encryption-keys'?: Array<EncryptedKey>;
  snapshots?: Array<Snapshot>;
  refs?: SnapshotReferences;
  'current-snapshot-id'?: number;
  'last-sequence-number'?: number;
  'snapshot-log'?: SnapshotLog;
  'metadata-log'?: MetadataLog;
  statistics?: Array<StatisticsFile>;
  'partition-statistics'?: Array<PartitionStatisticsFile>;
};

export type TableMetadataWritable = {
  'format-version': number;
  'table-uuid': string;
  location?: string;
  'last-updated-ms'?: number;
  /**
   * A long higher than all assigned row IDs; the next snapshot's first-row-id.
   */
  'next-row-id'?: number;
  properties?: {
    [key: string]: string;
  };
  schemas?: Array<SchemaWritable>;
  'current-schema-id'?: number;
  'last-column-id'?: number;
  'partition-specs'?: Array<PartitionSpecWritable>;
  'default-spec-id'?: number;
  'last-partition-id'?: number;
  'sort-orders'?: Array<SortOrderWritable>;
  'default-sort-order-id'?: number;
  'encryption-keys'?: Array<EncryptedKey>;
  snapshots?: Array<Snapshot>;
  refs?: SnapshotReferences;
  'current-snapshot-id'?: number;
  'last-sequence-number'?: number;
  'snapshot-log'?: SnapshotLog;
  'metadata-log'?: MetadataLog;
  statistics?: Array<StatisticsFile>;
  'partition-statistics'?: Array<PartitionStatisticsFile>;
};

export type SqlViewRepresentation = {
  type: string;
  sql: string;
  dialect: string;
};

export type ViewRepresentation = SqlViewRepresentation;

export type ViewHistoryEntry = {
  'version-id': number;
  'timestamp-ms': number;
};

export type ViewVersion = {
  'version-id': number;
  'timestamp-ms': number;
  /**
   * Schema ID to set as current, or -1 to set last added schema
   */
  'schema-id': number;
  summary: {
    [key: string]: string;
  };
  representations: Array<ViewRepresentation>;
  'default-catalog'?: string;
  'default-namespace': Namespace;
};

export type ViewMetadataReadable = {
  'view-uuid': string;
  'format-version': number;
  location: string;
  'current-version-id': number;
  versions: Array<ViewVersion>;
  'version-log': Array<ViewHistoryEntry>;
  schemas: Array<SchemaReadable>;
  properties?: {
    [key: string]: string;
  };
};

export type ViewMetadataWritable = {
  'view-uuid': string;
  'format-version': number;
  location: string;
  'current-version-id': number;
  versions: Array<ViewVersion>;
  'version-log': Array<ViewHistoryEntry>;
  schemas: Array<SchemaWritable>;
  properties?: {
    [key: string]: string;
  };
};

export type BaseUpdate = {
  action: string;
};

/**
 * Assigning a UUID to a table/view should only be done when creating the table/view. It is not safe to re-assign the UUID if a table/view already has a UUID assigned
 */
export type AssignUuidUpdate = BaseUpdate & {
  action: 'assign-uuid';
} & {
  action?: 'assign-uuid';
  uuid: string;
};

export type UpgradeFormatVersionUpdate = BaseUpdate & {
  action: 'upgrade-format-version';
} & {
  action?: 'upgrade-format-version';
  'format-version': number;
};

export type AddSchemaUpdateReadable = BaseUpdate & {
  action: 'add-schema';
} & {
  action?: 'add-schema';
  schema: SchemaReadable;
  /**
   * This optional field is **DEPRECATED for REMOVAL** since it more safe to handle this internally, and shouldn't be exposed to the clients.
   * The highest assigned column ID for the table. This is used to ensure columns are always assigned an unused ID when evolving schemas. When omitted, it will be computed on the server side.
   * @deprecated
   */
  'last-column-id'?: number;
};

export type AddSchemaUpdateWritable = BaseUpdate & {
  action: 'add-schema';
} & {
  action?: 'add-schema';
  schema: SchemaWritable;
  /**
   * This optional field is **DEPRECATED for REMOVAL** since it more safe to handle this internally, and shouldn't be exposed to the clients.
   * The highest assigned column ID for the table. This is used to ensure columns are always assigned an unused ID when evolving schemas. When omitted, it will be computed on the server side.
   * @deprecated
   */
  'last-column-id'?: number;
};

export type SetCurrentSchemaUpdate = BaseUpdate & {
  action: 'set-current-schema';
} & {
  action?: 'set-current-schema';
  /**
   * Schema ID to set as current, or -1 to set last added schema
   */
  'schema-id': number;
};

export type AddPartitionSpecUpdateReadable = BaseUpdate & {
  action: 'add-spec';
} & {
  action?: 'add-spec';
  spec: PartitionSpecReadable;
};

export type AddPartitionSpecUpdateWritable = BaseUpdate & {
  action: 'add-spec';
} & {
  action?: 'add-spec';
  spec: PartitionSpecWritable;
};

export type SetDefaultSpecUpdate = BaseUpdate & {
  action: 'set-default-spec';
} & {
  action?: 'set-default-spec';
  /**
   * Partition spec ID to set as the default, or -1 to set last added spec
   */
  'spec-id': number;
};

export type AddSortOrderUpdateReadable = BaseUpdate & {
  action: 'add-sort-order';
} & {
  action?: 'add-sort-order';
  'sort-order': SortOrderReadable;
};

export type AddSortOrderUpdateWritable = BaseUpdate & {
  action: 'add-sort-order';
} & {
  action?: 'add-sort-order';
  'sort-order': SortOrderWritable;
};

export type SetDefaultSortOrderUpdate = BaseUpdate & {
  action: 'set-default-sort-order';
} & {
  action?: 'set-default-sort-order';
  /**
   * Sort order ID to set as the default, or -1 to set last added sort order
   */
  'sort-order-id': number;
};

export type AddSnapshotUpdate = BaseUpdate & {
  action: 'add-snapshot';
} & {
  action?: 'add-snapshot';
  snapshot: Snapshot;
};

export type SetSnapshotRefUpdate = BaseUpdate & {
  action: 'set-snapshot-ref';
} & SnapshotReference & {
    action?: 'set-snapshot-ref';
    'ref-name': string;
  };

export type RemoveSnapshotsUpdate = BaseUpdate & {
  action: 'remove-snapshots';
} & {
  action?: 'remove-snapshots';
  'snapshot-ids': Array<number>;
};

export type RemoveSnapshotRefUpdate = BaseUpdate & {
  action: 'remove-snapshot-ref';
} & {
  action?: 'remove-snapshot-ref';
  'ref-name': string;
};

export type SetLocationUpdate = BaseUpdate & {
  action: 'set-location';
} & {
  action?: 'set-location';
  location: string;
};

export type SetPropertiesUpdate = BaseUpdate & {
  action: 'set-properties';
} & {
  action?: 'set-properties';
  updates: {
    [key: string]: string;
  };
};

export type RemovePropertiesUpdate = BaseUpdate & {
  action: 'remove-properties';
} & {
  action?: 'remove-properties';
  removals: Array<string>;
};

export type AddViewVersionUpdate = BaseUpdate & {
  action: 'add-view-version';
} & {
  action?: 'add-view-version';
  'view-version': ViewVersion;
};

export type SetCurrentViewVersionUpdate = BaseUpdate & {
  action: 'set-current-view-version';
} & {
  action?: 'set-current-view-version';
  /**
   * The view version id to set as current, or -1 to set last added view version id
   */
  'view-version-id': number;
};

export type SetStatisticsUpdate = BaseUpdate & {
  action: 'set-statistics';
} & {
  action?: 'set-statistics';
  /**
   * This optional field is **DEPRECATED for REMOVAL** since it contains redundant information. Clients should use the `statistics.snapshot-id` field instead.
   * @deprecated
   */
  'snapshot-id'?: number;
  statistics: StatisticsFile;
};

export type RemoveStatisticsUpdate = BaseUpdate & {
  action: 'remove-statistics';
} & {
  action?: 'remove-statistics';
  'snapshot-id': number;
};

export type SetPartitionStatisticsUpdate = BaseUpdate & {
  action: 'set-partition-statistics';
} & {
  action?: 'set-partition-statistics';
  'partition-statistics': PartitionStatisticsFile;
};

export type RemovePartitionStatisticsUpdate = BaseUpdate & {
  action: 'remove-partition-statistics';
} & {
  action?: 'remove-partition-statistics';
  'snapshot-id': number;
};

export type RemovePartitionSpecsUpdate = BaseUpdate & {
  action: 'remove-partition-specs';
} & {
  action?: 'remove-partition-specs';
  'spec-ids': Array<number>;
};

export type RemoveSchemasUpdate = BaseUpdate & {
  action: 'remove-schemas';
} & {
  action?: 'remove-schemas';
  'schema-ids': Array<number>;
};

export type AddEncryptionKeyUpdate = BaseUpdate & {
  action: 'add-encryption-key';
} & {
  action?: 'add-encryption-key';
  'encryption-key': EncryptedKey;
};

export type RemoveEncryptionKeyUpdate = BaseUpdate & {
  action: 'remove-encryption-key';
} & {
  action?: 'remove-encryption-key';
  'key-id': string;
};

export type TableUpdateReadable =
  | AssignUuidUpdate
  | UpgradeFormatVersionUpdate
  | AddSchemaUpdateReadable
  | SetCurrentSchemaUpdate
  | AddPartitionSpecUpdateReadable
  | SetDefaultSpecUpdate
  | AddSortOrderUpdateReadable
  | SetDefaultSortOrderUpdate
  | AddSnapshotUpdate
  | SetSnapshotRefUpdate
  | RemoveSnapshotsUpdate
  | RemoveSnapshotRefUpdate
  | SetLocationUpdate
  | SetPropertiesUpdate
  | RemovePropertiesUpdate
  | SetStatisticsUpdate
  | RemoveStatisticsUpdate
  | RemovePartitionSpecsUpdate
  | RemoveSchemasUpdate
  | AddEncryptionKeyUpdate
  | RemoveEncryptionKeyUpdate;

export type TableUpdateWritable =
  | AssignUuidUpdate
  | UpgradeFormatVersionUpdate
  | AddSchemaUpdateWritable
  | SetCurrentSchemaUpdate
  | AddPartitionSpecUpdateWritable
  | SetDefaultSpecUpdate
  | AddSortOrderUpdateWritable
  | SetDefaultSortOrderUpdate
  | AddSnapshotUpdate
  | SetSnapshotRefUpdate
  | RemoveSnapshotsUpdate
  | RemoveSnapshotRefUpdate
  | SetLocationUpdate
  | SetPropertiesUpdate
  | RemovePropertiesUpdate
  | SetStatisticsUpdate
  | RemoveStatisticsUpdate
  | RemovePartitionSpecsUpdate
  | RemoveSchemasUpdate
  | AddEncryptionKeyUpdate
  | RemoveEncryptionKeyUpdate;

export type ViewUpdateReadable =
  | AssignUuidUpdate
  | UpgradeFormatVersionUpdate
  | AddSchemaUpdateReadable
  | SetLocationUpdate
  | SetPropertiesUpdate
  | RemovePropertiesUpdate
  | AddViewVersionUpdate
  | SetCurrentViewVersionUpdate;

export type ViewUpdateWritable =
  | AssignUuidUpdate
  | UpgradeFormatVersionUpdate
  | AddSchemaUpdateWritable
  | SetLocationUpdate
  | SetPropertiesUpdate
  | RemovePropertiesUpdate
  | AddViewVersionUpdate
  | SetCurrentViewVersionUpdate;

export type TableRequirement = {
  type: string;
};

/**
 * The table must not already exist; used for create transactions
 */
export type AssertCreate = TableRequirement & {
  type: 'assert-create';
} & {
  type: 'assert-create';
};

/**
 * The table UUID must match the requirement's `uuid`
 */
export type AssertTableUuid = TableRequirement & {
  type: 'assert-table-uuid';
} & {
  type: 'assert-table-uuid';
  uuid: string;
};

/**
 * The table branch or tag identified by the requirement's `ref` must reference the requirement's `snapshot-id`.
 * The `snapshot-id` field is required in this object, but in the case of a `null`
 * the ref must not already exist.
 *
 */
export type AssertRefSnapshotId = TableRequirement & {
  type: 'assert-ref-snapshot-id';
} & {
  type?: 'assert-ref-snapshot-id';
  ref: string;
  'snapshot-id': number;
};

/**
 * The table's last assigned column id must match the requirement's `last-assigned-field-id`
 */
export type AssertLastAssignedFieldId = TableRequirement & {
  type: 'assert-last-assigned-field-id';
} & {
  type?: 'assert-last-assigned-field-id';
  'last-assigned-field-id': number;
};

/**
 * The table's current schema id must match the requirement's `current-schema-id`
 */
export type AssertCurrentSchemaId = TableRequirement & {
  type: 'assert-current-schema-id';
} & {
  type?: 'assert-current-schema-id';
  'current-schema-id': number;
};

/**
 * The table's last assigned partition id must match the requirement's `last-assigned-partition-id`
 */
export type AssertLastAssignedPartitionId = TableRequirement & {
  type: 'assert-last-assigned-partition-id';
} & {
  type?: 'assert-last-assigned-partition-id';
  'last-assigned-partition-id': number;
};

/**
 * The table's default spec id must match the requirement's `default-spec-id`
 */
export type AssertDefaultSpecId = TableRequirement & {
  type: 'assert-default-spec-id';
} & {
  type?: 'assert-default-spec-id';
  'default-spec-id': number;
};

/**
 * The table's default sort order id must match the requirement's `default-sort-order-id`
 */
export type AssertDefaultSortOrderId = TableRequirement & {
  type: 'assert-default-sort-order-id';
} & {
  type?: 'assert-default-sort-order-id';
  'default-sort-order-id': number;
};

export type ViewRequirement = {
  type?: 'assert-view-uuid';
} & AssertViewUuid;

/**
 * The view UUID must match the requirement's `uuid`
 */
export type AssertViewUuid = {
  type: 'assert-view-uuid';
  uuid: string;
};

export type StorageCredential = {
  /**
   * Indicates a storage location prefix where the credential is relevant. Clients should choose the most specific prefix (by selecting the longest prefix) if several credentials of the same type are available.
   */
  prefix: string;
  config: {
    [key: string]: string;
  };
};

export type LoadCredentialsResponse = {
  'storage-credentials': Array<StorageCredential>;
};

/**
 * Result used when a table is successfully loaded.
 *
 *
 * The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
 * Clients can check whether metadata has changed by comparing metadata locations after the table has been created.
 *
 *
 * The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.
 *
 *
 * The following configurations should be respected by clients:
 *
 * ## General Configurations
 *
 * - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled
 *
 * ## AWS Configurations
 *
 * The following configurations should be respected when working with tables stored in AWS S3
 * - `client.region`: region to configure client for making requests to AWS
 * - `s3.access-key-id`: id for credentials that provide access to the data in S3
 * - `s3.secret-access-key`: secret for credentials that provide access to data in S3
 * - `s3.session-token`: if present, this value should be used for as the session token
 * - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
 * - `s3.cross-region-access-enabled`: if `true`, S3 Cross-Region bucket access is enabled
 *
 * ## Storage Credentials
 *
 * Credentials for ADLS / GCS / S3 / ... are provided through the `storage-credentials` field.
 * Clients must first check whether the respective credentials exist in the `storage-credentials` field before checking the `config` for credentials.
 *
 */
export type LoadTableResultReadable = {
  /**
   * May be null if the table is staged as part of a transaction
   */
  'metadata-location'?: string;
  metadata: TableMetadataReadable;
  config?: {
    [key: string]: string;
  };
  'storage-credentials'?: Array<StorageCredential>;
};

/**
 * Result used when a table is successfully loaded.
 *
 *
 * The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
 * Clients can check whether metadata has changed by comparing metadata locations after the table has been created.
 *
 *
 * The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.
 *
 *
 * The following configurations should be respected by clients:
 *
 * ## General Configurations
 *
 * - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled
 *
 * ## AWS Configurations
 *
 * The following configurations should be respected when working with tables stored in AWS S3
 * - `client.region`: region to configure client for making requests to AWS
 * - `s3.access-key-id`: id for credentials that provide access to the data in S3
 * - `s3.secret-access-key`: secret for credentials that provide access to data in S3
 * - `s3.session-token`: if present, this value should be used for as the session token
 * - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
 * - `s3.cross-region-access-enabled`: if `true`, S3 Cross-Region bucket access is enabled
 *
 * ## Storage Credentials
 *
 * Credentials for ADLS / GCS / S3 / ... are provided through the `storage-credentials` field.
 * Clients must first check whether the respective credentials exist in the `storage-credentials` field before checking the `config` for credentials.
 *
 */
export type LoadTableResultWritable = {
  /**
   * May be null if the table is staged as part of a transaction
   */
  'metadata-location'?: string;
  metadata: TableMetadataWritable;
  config?: {
    [key: string]: string;
  };
  'storage-credentials'?: Array<StorageCredential>;
};

/**
 * Scan and planning tasks for server-side scan planning
 * - `plan-tasks` contains opaque units of planning work
 * - `file-scan-tasks` contains a partial or complete list of table scan tasks
 * - `delete-files` contains delete files referenced by file scan tasks
 * Each plan task must be passed to the fetchScanTasks endpoint to fetch the file scan tasks for the plan task.
 * The list of delete files must contain all delete files referenced by the file scan tasks.
 *
 */
export type ScanTasks = {
  /**
   * Delete files referenced by file scan tasks
   */
  'delete-files'?: Array<DeleteFile>;
  'file-scan-tasks'?: Array<FileScanTask>;
  'plan-tasks'?: Array<PlanTask>;
};

/**
 * Completed server-side planning result
 */
export type CompletedPlanningResult = ScanTasks & {
  status: PlanStatus;
};

export type CompletedPlanningWithIdResult = CompletedPlanningResult & {
  /**
   * ID used to track a planning request
   */
  'plan-id'?: string;
};

/**
 * Failed server-side planning result
 */
export type FailedPlanningResult = IcebergErrorResponse & {
  status: PlanStatus;
};

export type AsyncPlanningResult = {
  status: PlanStatus;
  /**
   * ID used to track a planning request
   */
  'plan-id'?: string;
};

/**
 * Empty server-side planning result
 */
export type EmptyPlanningResult = {
  status: PlanStatus;
};

/**
 * Status of a server-side planning operation
 */
export type PlanStatus = 'completed' | 'submitted' | 'cancelled' | 'failed';

/**
 * Result of server-side scan planning for fetchPlanningResult
 */
export type FetchPlanningResult =
  | ({
      status?: 'completed';
    } & CompletedPlanningResult)
  | ({
      status?: 'failed';
    } & FailedPlanningResult)
  | ({
      status?: 'submitted' | 'cancelled';
    } & EmptyPlanningResult);

/**
 * Result of server-side scan planning for planTableScan
 */
export type PlanTableScanResult =
  | ({
      status?: 'completed';
    } & CompletedPlanningWithIdResult)
  | ({
      status?: 'failed';
    } & FailedPlanningResult)
  | ({
      status?: 'submitted';
    } & AsyncPlanningResult)
  | ({
      status?: 'cancelled';
    } & EmptyPlanningResult);

/**
 * Response schema for fetchScanTasks
 */
export type FetchScanTasksResult = ScanTasks;

export type CommitTableRequestReadable = {
  /**
   * Table identifier to update; must be present for CommitTransactionRequest
   */
  identifier?: TableIdentifier;
  requirements: Array<TableRequirement>;
  updates: Array<TableUpdateReadable>;
};

export type CommitTableRequestWritable = {
  /**
   * Table identifier to update; must be present for CommitTransactionRequest
   */
  identifier?: TableIdentifier;
  requirements: Array<TableRequirement>;
  updates: Array<TableUpdateWritable>;
};

export type CommitViewRequestReadable = {
  /**
   * View identifier to update
   */
  identifier?: TableIdentifier;
  requirements?: Array<ViewRequirement>;
  updates: Array<ViewUpdateReadable>;
};

export type CommitViewRequestWritable = {
  /**
   * View identifier to update
   */
  identifier?: TableIdentifier;
  requirements?: Array<ViewRequirement>;
  updates: Array<ViewUpdateWritable>;
};

export type CommitTransactionRequestReadable = {
  'table-changes': Array<CommitTableRequestReadable>;
};

export type CommitTransactionRequestWritable = {
  'table-changes': Array<CommitTableRequestWritable>;
};

export type CreateTableRequestReadable = {
  name: string;
  location?: string;
  schema: SchemaReadable;
  'partition-spec'?: PartitionSpecReadable;
  'write-order'?: SortOrderReadable;
  'stage-create'?: boolean;
  properties?: {
    [key: string]: string;
  };
};

export type CreateTableRequestWritable = {
  name: string;
  location?: string;
  schema: SchemaWritable;
  'partition-spec'?: PartitionSpecWritable;
  'write-order'?: SortOrderWritable;
  'stage-create'?: boolean;
  properties?: {
    [key: string]: string;
  };
};

export type RegisterTableRequest = {
  name: string;
  'metadata-location': string;
  /**
   * Whether to overwrite table metadata if the table already exists
   */
  overwrite?: boolean;
};

export type CreateViewRequestReadable = {
  name: string;
  location?: string;
  schema: SchemaReadable;
  /**
   * The view version to create, will replace the schema-id sent within the view-version with the id assigned to the provided schema
   */
  'view-version': ViewVersion;
  properties: {
    [key: string]: string;
  };
};

export type CreateViewRequestWritable = {
  name: string;
  location?: string;
  schema: SchemaWritable;
  /**
   * The view version to create, will replace the schema-id sent within the view-version with the id assigned to the provided schema
   */
  'view-version': ViewVersion;
  properties: {
    [key: string]: string;
  };
};

/**
 * Result used when a view is successfully loaded.
 *
 * The view metadata JSON is returned in the `metadata` field. The corresponding file location of view metadata is returned in the `metadata-location` field.
 * Clients can check whether metadata has changed by comparing metadata locations after the view has been created.
 *
 * The `config` map returns view-specific configuration for the view's resources.
 *
 * The following configurations should be respected by clients:
 *
 * ## General Configurations
 *
 * - `token`: Authorization bearer token to use for view requests if OAuth2 security is enabled
 *
 */
export type LoadViewResultReadable = {
  'metadata-location': string;
  metadata: ViewMetadataReadable;
  config?: {
    [key: string]: string;
  };
};

/**
 * Result used when a view is successfully loaded.
 *
 * The view metadata JSON is returned in the `metadata` field. The corresponding file location of view metadata is returned in the `metadata-location` field.
 * Clients can check whether metadata has changed by comparing metadata locations after the view has been created.
 *
 * The `config` map returns view-specific configuration for the view's resources.
 *
 * The following configurations should be respected by clients:
 *
 * ## General Configurations
 *
 * - `token`: Authorization bearer token to use for view requests if OAuth2 security is enabled
 *
 */
export type LoadViewResultWritable = {
  'metadata-location': string;
  metadata: ViewMetadataWritable;
  config?: {
    [key: string]: string;
  };
};

/**
 * Token type identifier, from RFC 8693 Section 3
 *
 * See https://datatracker.ietf.org/doc/html/rfc8693#section-3
 */
export type TokenType =
  | 'urn:ietf:params:oauth:token-type:access_token'
  | 'urn:ietf:params:oauth:token-type:refresh_token'
  | 'urn:ietf:params:oauth:token-type:id_token'
  | 'urn:ietf:params:oauth:token-type:saml1'
  | 'urn:ietf:params:oauth:token-type:saml2'
  | 'urn:ietf:params:oauth:token-type:jwt';

/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
 *
 * OAuth2 client credentials request
 *
 * See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4
 * @deprecated
 */
export type OAuthClientCredentialsRequest = {
  grant_type: 'client_credentials';
  scope?: string;
  /**
   * Client ID
   *
   * This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
   */
  client_id: string;
  /**
   * Client secret
   *
   * This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
   */
  client_secret: string;
};

/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
 *
 * OAuth2 token exchange request
 *
 * See https://datatracker.ietf.org/doc/html/rfc8693
 * @deprecated
 */
export type OAuthTokenExchangeRequest = {
  grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange';
  scope?: string;
  requested_token_type?: TokenType;
  /**
   * Subject token for token exchange request
   */
  subject_token: string;
  subject_token_type: TokenType;
  /**
   * Actor token for token exchange request
   */
  actor_token?: string;
  actor_token_type?: TokenType;
};

/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
 * @deprecated
 */
export type OAuthTokenRequest = OAuthClientCredentialsRequest | OAuthTokenExchangeRequest;

export type CounterResult = {
  unit: string;
  value: number;
};

export type TimerResult = {
  'time-unit': string;
  count: number;
  'total-duration': number;
};

export type MetricResult = CounterResult | TimerResult;

export type Metrics = {
  [key: string]: MetricResult;
};

export type ReportMetricsRequest = (ScanReport | CommitReport) & {
  'report-type': string;
};

export type ScanReport = {
  'table-name': string;
  'snapshot-id': number;
  filter: Expression;
  'schema-id': number;
  'projected-field-ids': Array<number>;
  'projected-field-names': Array<string>;
  metrics: Metrics;
  metadata?: {
    [key: string]: string;
  };
};

export type CommitReport = {
  'table-name': string;
  'snapshot-id': number;
  'sequence-number': number;
  operation: string;
  metrics: Metrics;
  metadata?: {
    [key: string]: string;
  };
};

/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
 * @deprecated
 */
export type OAuthError = {
  error:
    | 'invalid_request'
    | 'invalid_client'
    | 'invalid_grant'
    | 'unauthorized_client'
    | 'unsupported_grant_type'
    | 'invalid_scope';
  error_description?: string;
  error_uri?: string;
};

/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
 * @deprecated
 */
export type OAuthTokenResponse = {
  /**
   * The access token, for client credentials or token exchange
   */
  access_token: string;
  /**
   * Access token type for client credentials or token exchange
   *
   * See https://datatracker.ietf.org/doc/html/rfc6749#section-7.1
   */
  token_type: 'bearer' | 'mac' | 'N_A';
  /**
   * Lifetime of the access token in seconds for client credentials or token exchange
   */
  expires_in?: number;
  issued_token_type?: TokenType;
  /**
   * Refresh token for client credentials or token exchange
   */
  refresh_token?: string;
  /**
   * Authorization scope for client credentials or token exchange
   */
  scope?: string;
};

/**
 * JSON wrapper for all error responses (non-2xx)
 */
export type IcebergErrorResponse = {
  error: ErrorModel;
};

export type CreateNamespaceResponse = {
  namespace: Namespace;
  /**
   * Properties stored on the namespace, if supported by the server.
   */
  properties?: {
    [key: string]: string;
  };
};

export type GetNamespaceResponse = {
  namespace: Namespace;
  /**
   * Properties stored on the namespace, if supported by the server. If the server does not support namespace properties, it should return null for this field. If namespace properties are supported, but none are set, it should return an empty object.
   */
  properties?: {
    [key: string]: string;
  };
  'namespace-uuid'?: string;
};

export type ListTablesResponse = {
  'next-page-token'?: PageToken;
  identifiers?: Array<TableIdentifier>;
  'table-uuids'?: Array<string>;
  'protection-status'?: Array<boolean>;
};

export type ListNamespacesResponse = {
  'next-page-token'?: PageToken;
  namespaces?: Array<Namespace>;
  'namespace-uuids'?: Array<string>;
  'protection-status'?: Array<boolean>;
};

export type UpdateNamespacePropertiesResponse = {
  /**
   * List of property keys that were added or updated
   */
  updated: Array<string>;
  /**
   * List of properties that were removed
   */
  removed: Array<string>;
  /**
   * List of properties requested for removal that were not found in the namespace's properties. Represents a partial success response. Server's do not need to implement this.
   */
  missing?: Array<string>;
};

export type CommitTableResponseReadable = {
  'metadata-location': string;
  metadata: TableMetadataReadable;
};

export type CommitTableResponseWritable = {
  'metadata-location': string;
  metadata: TableMetadataWritable;
};

export type StatisticsFile = {
  'snapshot-id': number;
  'statistics-path': string;
  'file-size-in-bytes': number;
  'file-footer-size-in-bytes': number;
  'blob-metadata': Array<BlobMetadata>;
};

export type BlobMetadata = {
  type: string;
  'snapshot-id': number;
  'sequence-number': number;
  fields: Array<number>;
  properties?: {
    [key: string]: string;
  };
};

export type PartitionStatisticsFile = {
  'snapshot-id': number;
  'statistics-path': string;
  'file-size-in-bytes': number;
};

export type BooleanTypeValue = boolean;

export type IntegerTypeValue = number;

export type LongTypeValue = number;

export type FloatTypeValue = number;

export type DoubleTypeValue = number;

/**
 * Decimal type values are serialized as strings. Decimals with a positive scale serialize as numeric plain text, while decimals with a negative scale use scientific notation and the exponent will be equal to the negated scale. For instance, a decimal with a positive scale is '123.4500', with zero scale is '2', and with a negative scale is '2E+20'
 */
export type DecimalTypeValue = string;

export type StringTypeValue = string;

/**
 * UUID type values are serialized as a 36-character lowercase string in standard UUID format as specified by RFC-4122
 */
export type UuidTypeValue = string;

/**
 * Date type values follow the 'YYYY-MM-DD' ISO-8601 standard date format
 */
export type DateTypeValue = string;

/**
 * Time type values follow the 'HH:MM:SS.ssssss' ISO-8601 format with microsecond precision
 */
export type TimeTypeValue = string;

/**
 * Timestamp type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss' ISO-8601 format with microsecond precision
 */
export type TimestampTypeValue = string;

/**
 * TimestampTz type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss+00:00' ISO-8601 format with microsecond precision, and a timezone offset (+00:00 for UTC)
 */
export type TimestampTzTypeValue = string;

/**
 * Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss' ISO-8601 format with nanosecond precision
 */
export type TimestampNanoTypeValue = string;

/**
 * Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss+00:00' ISO-8601 format with nanosecond precision, and a timezone offset (+00:00 for UTC)
 */
export type TimestampTzNanoTypeValue = string;

/**
 * Fixed length type values are stored and serialized as an uppercase hexadecimal string preserving the fixed length
 */
export type FixedTypeValue = string;

/**
 * Binary type values are stored and serialized as an uppercase hexadecimal string
 */
export type BinaryTypeValue = string;

export type CountMap = {
  /**
   * List of integer column ids for each corresponding value
   */
  keys?: Array<IntegerTypeValue>;
  /**
   * List of Long values, matched to 'keys' by index
   */
  values?: Array<LongTypeValue>;
};

export type ValueMap = {
  /**
   * List of integer column ids for each corresponding value
   */
  keys?: Array<IntegerTypeValue>;
  /**
   * List of primitive type values, matched to 'keys' by index
   */
  values?: Array<PrimitiveTypeValue>;
};

export type PrimitiveTypeValue =
  | BooleanTypeValue
  | IntegerTypeValue
  | LongTypeValue
  | FloatTypeValue
  | DoubleTypeValue
  | DecimalTypeValue
  | StringTypeValue
  | UuidTypeValue
  | DateTypeValue
  | TimeTypeValue
  | TimestampTypeValue
  | TimestampTzTypeValue
  | TimestampNanoTypeValue
  | TimestampTzNanoTypeValue
  | FixedTypeValue
  | BinaryTypeValue;

export type FileFormat = 'avro' | 'orc' | 'parquet' | 'puffin';

export type ContentFile = {
  content: string;
  'file-path': string;
  'file-format': FileFormat;
  'spec-id': number;
  /**
   * A list of partition field values ordered based on the fields of the partition spec specified by the `spec-id`
   */
  partition: Array<PrimitiveTypeValue>;
  /**
   * Total file size in bytes
   */
  'file-size-in-bytes': number;
  /**
   * Number of records in the file
   */
  'record-count': number;
  /**
   * Encryption key metadata blob
   */
  'key-metadata'?: BinaryTypeValue;
  /**
   * List of splittable offsets
   */
  'split-offsets'?: Array<number>;
  'sort-order-id'?: number;
};

export type DataFile = ContentFile & {
  content: 'data';
} & {
  content: 'data';
  /**
   * The first row ID assigned to the first row in the data file
   */
  'first-row-id'?: number;
  /**
   * Map of column id to total count, including null and NaN
   */
  'column-sizes'?: CountMap;
  /**
   * Map of column id to null value count
   */
  'value-counts'?: CountMap;
  /**
   * Map of column id to null value count
   */
  'null-value-counts'?: CountMap;
  /**
   * Map of column id to number of NaN values in the column
   */
  'nan-value-counts'?: CountMap;
  /**
   * Map of column id to lower bound primitive type values
   */
  'lower-bounds'?: ValueMap;
  /**
   * Map of column id to upper bound primitive type values
   */
  'upper-bounds'?: ValueMap;
};

export type DeleteFile =
  | ({
      content?: 'position-deletes';
    } & PositionDeleteFile)
  | ({
      content?: 'equality-deletes';
    } & EqualityDeleteFile);

export type PositionDeleteFile = ContentFile & {
  content: 'position-deletes';
} & {
  content: 'position-deletes';
  /**
   * Offset within the delete file of delete content
   */
  'content-offset'?: number;
  /**
   * Length, in bytes, of the delete content; required if content-offset is present
   */
  'content-size-in-bytes'?: number;
};

export type EqualityDeleteFile = ContentFile & {
  content: 'equality-deletes';
} & {
  content: 'equality-deletes';
  /**
   * List of equality field IDs
   */
  'equality-ids'?: Array<number>;
};

export type PlanTableScanRequest = {
  /**
   * Identifier for the snapshot to scan in a point-in-time scan
   */
  'snapshot-id'?: number;
  /**
   * List of selected schema fields
   */
  select?: Array<FieldName>;
  /**
   * Expression used to filter the table data
   */
  filter?: Expression;
  /**
   * Enables case sensitive field matching for filter and select
   */
  'case-sensitive'?: boolean;
  /**
   * Whether to use the schema at the time the snapshot was written.
   * When time travelling, the snapshot schema should be used (true). When scanning a branch, the table schema should be used (false).
   */
  'use-snapshot-schema'?: boolean;
  /**
   * Starting snapshot ID for an incremental scan (exclusive)
   */
  'start-snapshot-id'?: number;
  /**
   * Ending snapshot ID for an incremental scan (inclusive).
   * Required when start-snapshot-id is specified.
   */
  'end-snapshot-id'?: number;
  /**
   * List of fields for which the service should send column stats.
   */
  'stats-fields'?: Array<FieldName>;
};

/**
 * A full field name (including parent field names), such as those passed in APIs like Java `Schema#findField(String name)`.
 * The nested field name follows these rules - Nested struct fields are named by concatenating field names at each struct level using dot (`.`) delimiter, e.g. employer.contact_info.address.zip_code - Nested fields in a map key are named using the keyword `key`, e.g. employee_address_map.key.first_name - Nested fields in a map value are named using the keyword `value`, e.g. employee_address_map.value.zip_code - Nested fields in a list are named using the keyword `element`, e.g. employees.element.first_name
 */
export type FieldName = string;

export type FetchScanTasksRequest = {
  'plan-task': PlanTask;
};

/**
 * An opaque string provided by the REST server that represents a unit of work to produce file scan tasks for scan planning. This allows clients to fetch tasks across multiple requests to accommodate large result sets.
 */
export type PlanTask = string;

export type FileScanTask = {
  'data-file': DataFile;
  /**
   * A list of indices in the delete files array (0-based)
   */
  'delete-file-references'?: Array<number>;
  /**
   * An optional filter to be applied to rows in this file scan task.
   * If the residual is not present, the client must produce the residual or use the original filter.
   */
  'residual-filter'?: Expression;
};

/**
 * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
 */
export type Namespace2 = string;

/**
 * An optional prefix in the path
 */
export type Prefix = string;

/**
 * A table name
 */
export type Table = string;

/**
 * ID used to track a planning request
 */
export type PlanId = string;

/**
 * A view name
 */
export type View = string;

/**
 * Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
 * Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
 * The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
 *
 */
export type DataAccess = 'vended-credentials' | 'remote-signing';

export type PageToken2 = PageToken;

/**
 * For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
 */
export type PageSize = number;

/**
 * Identifies a unique version of the table metadata.
 */
export type Etag = string;

export type GetConfigData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Warehouse location or identifier to request from the service
     */
    warehouse?: string;
  };
  url: '/v1/config';
};

export type GetConfigErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type GetConfigError = GetConfigErrors[keyof GetConfigErrors];

export type GetConfigResponses = {
  /**
   * Server specified configuration values.
   */
  200: CatalogConfig;
};

export type GetConfigResponse = GetConfigResponses[keyof GetConfigResponses];

export type GetTokenData = {
  body: OAuthTokenRequest;
  path?: never;
  query?: never;
  url: '/v1/oauth/tokens';
};

export type GetTokenErrors = {
  /**
   * OAuth2 error response
   */
  400: OAuthError;
  /**
   * OAuth2 error response
   */
  401: OAuthError;
  /**
   * OAuth2 error response
   */
  '5XX': OAuthError;
};

export type GetTokenError = GetTokenErrors[keyof GetTokenErrors];

export type GetTokenResponses = {
  /**
   * OAuth2 token response for client credentials or token exchange
   */
  200: OAuthTokenResponse;
};

export type GetTokenResponse = GetTokenResponses[keyof GetTokenResponses];

export type ListNamespacesData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
  };
  query?: {
    pageToken?: PageToken;
    /**
     * For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
     */
    pageSize?: number;
    /**
     * An optional namespace, underneath which to list namespaces. If not provided or empty, all top-level namespaces should be listed. If parent is a multipart namespace, the parts must be separated by the unit separator (`0x1F`) byte.
     */
    parent?: string;
    /**
     * If true, include the `namespace-uuids` field in the response
     */
    returnUuids?: boolean;
    /**
     * If true, include the `protection-status` field in the response
     */
    returnProtectionStatus?: boolean;
  };
  url: '/v1/{prefix}/namespaces';
};

export type ListNamespacesErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - Namespace provided in the `parent` query parameter is not found.
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type ListNamespacesError = ListNamespacesErrors[keyof ListNamespacesErrors];

export type ListNamespacesResponses = {
  /**
   * A list of namespaces
   */
  200: ListNamespacesResponse;
};

export type ListNamespacesResponse2 = ListNamespacesResponses[keyof ListNamespacesResponses];

export type CreateNamespaceData = {
  body: CreateNamespaceRequest;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces';
};

export type CreateNamespaceErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Acceptable / Unsupported Operation. The server does not support this operation.
   */
  406: ErrorModel;
  /**
   * Conflict - The namespace already exists
   */
  409: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type CreateNamespaceError = CreateNamespaceErrors[keyof CreateNamespaceErrors];

export type CreateNamespaceResponses = {
  /**
   * Represents a successful call to create a namespace. Returns the namespace created, as well as any properties that were stored for the namespace, including those the server might have added. Implementations are not required to support namespace properties.
   */
  200: CreateNamespaceResponse;
};

export type CreateNamespaceResponse2 = CreateNamespaceResponses[keyof CreateNamespaceResponses];

export type DropNamespaceData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
  };
  query?: {
    /**
     * If force and recursive are set to true, immediately delete all contents of the namespace without considering soft-delete policies. Force has no effect without recursive=true.
     */
    force?: boolean;
    /**
     * Delete a namespace and its contents. This means all tables, views, and namespaces under this namespace will be deleted. The namespace itself will also be deleted. If the warehouse containing the namespace is configured with a soft-deletion profile, the `force` flag has to be provided. The deletion will not be a soft-deletion. Every table, view and namespace will be gone as soon as this call returns. Depending on whether the `purge` flag was set to true, the data will be queued for deletion too. Any pending `tabular_expiration` will be cancelled. If there is a running `tabular_expiration`, this call will fail with a `409 Conflict` error.
     */
    recursive?: boolean;
    /**
     * If recursive is true, also deletes table and view data. If false, only metadata is dropped from the catalog, table location remains untouched. Defaults to true for all tables managed by Lakekeeper.
     */
    purge?: boolean;
  };
  url: '/v1/{prefix}/namespaces/{namespace}';
};

export type DropNamespaceErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - Namespace to delete does not exist.
   */
  404: IcebergErrorResponse;
  /**
   * Not Empty - Namespace to delete is not empty.
   */
  409: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type DropNamespaceError = DropNamespaceErrors[keyof DropNamespaceErrors];

export type DropNamespaceResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type DropNamespaceResponse = DropNamespaceResponses[keyof DropNamespaceResponses];

export type LoadNamespaceMetadataData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
  };
  query?: {
    /**
     * If true, include the `namespace-uuid` field in the response
     */
    returnUuid?: boolean;
  };
  url: '/v1/{prefix}/namespaces/{namespace}';
};

export type LoadNamespaceMetadataErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - Namespace not found
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type LoadNamespaceMetadataError =
  LoadNamespaceMetadataErrors[keyof LoadNamespaceMetadataErrors];

export type LoadNamespaceMetadataResponses = {
  /**
   * Returns a namespace, as well as any properties stored on the namespace if namespace properties are supported by the server.
   */
  200: GetNamespaceResponse;
};

export type LoadNamespaceMetadataResponse =
  LoadNamespaceMetadataResponses[keyof LoadNamespaceMetadataResponses];

export type NamespaceExistsData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}';
};

export type NamespaceExistsErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - Namespace not found
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type NamespaceExistsError = NamespaceExistsErrors[keyof NamespaceExistsErrors];

export type NamespaceExistsResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type NamespaceExistsResponse = NamespaceExistsResponses[keyof NamespaceExistsResponses];

export type UpdatePropertiesData = {
  body: UpdateNamespacePropertiesRequest;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/properties';
};

export type UpdatePropertiesErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - Namespace not found
   */
  404: IcebergErrorResponse;
  /**
   * Not Acceptable / Unsupported Operation. The server does not support this operation.
   */
  406: ErrorModel;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * Unprocessable Entity - A property key was included in both `removals` and `updates`
   */
  422: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type UpdatePropertiesError = UpdatePropertiesErrors[keyof UpdatePropertiesErrors];

export type UpdatePropertiesResponses = {
  /**
   * JSON data response for a synchronous update properties request.
   */
  200: UpdateNamespacePropertiesResponse;
};

export type UpdatePropertiesResponse = UpdatePropertiesResponses[keyof UpdatePropertiesResponses];

export type ListTablesData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
  };
  query?: {
    pageToken?: PageToken;
    /**
     * For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
     */
    pageSize?: number;
    /**
     * If true, include the `table-uuids` field in the response
     */
    returnUuids?: boolean;
    /**
     * If true, include the `protection-status` field in the response
     */
    returnProtectionStatus?: boolean;
  };
  url: '/v1/{prefix}/namespaces/{namespace}/tables';
};

export type ListTablesErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - The namespace specified does not exist
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type ListTablesError = ListTablesErrors[keyof ListTablesErrors];

export type ListTablesResponses = {
  /**
   * A list of table identifiers
   */
  200: ListTablesResponse;
};

export type ListTablesResponse2 = ListTablesResponses[keyof ListTablesResponses];

export type CreateTableData = {
  body: CreateTableRequestWritable;
  headers?: {
    /**
     * Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
     * Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
     * The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
     *
     */
    'X-Iceberg-Access-Delegation'?: 'vended-credentials' | 'remote-signing';
  };
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/tables';
};

export type CreateTableErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - The namespace specified does not exist
   */
  404: IcebergErrorResponse;
  /**
   * Conflict - The table already exists
   */
  409: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type CreateTableError = CreateTableErrors[keyof CreateTableErrors];

export type CreateTableResponses = {
  /**
   * Table metadata result after creating a table
   */
  200: LoadTableResultReadable;
};

export type CreateTableResponse = CreateTableResponses[keyof CreateTableResponses];

export type PlanTableScanData = {
  body?: PlanTableScanRequest;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}/plan';
};

export type PlanTableScanErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, the table does not exist - NoSuchNamespaceException, the namespace does not exist
   */
  404: IcebergErrorResponse;
  /**
   * Not Acceptable / Unsupported Operation. The server does not support this operation.
   */
  406: ErrorModel;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type PlanTableScanError = PlanTableScanErrors[keyof PlanTableScanErrors];

export type PlanTableScanResponses = {
  /**
   * Result of submitting a table scan to plan
   */
  200: PlanTableScanResult;
};

export type PlanTableScanResponse = PlanTableScanResponses[keyof PlanTableScanResponses];

export type CancelPlanningData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
    /**
     * ID used to track a planning request
     */
    'plan-id': string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}/plan/{plan-id}';
};

export type CancelPlanningErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, the table does not exist - NoSuchNamespaceException, the namespace does not exist
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type CancelPlanningError = CancelPlanningErrors[keyof CancelPlanningErrors];

export type CancelPlanningResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type CancelPlanningResponse = CancelPlanningResponses[keyof CancelPlanningResponses];

export type FetchPlanningResultData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
    /**
     * ID used to track a planning request
     */
    'plan-id': string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}/plan/{plan-id}';
};

export type FetchPlanningResultErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchPlanIdException, the plan-id does not exist - NoSuchTableException, the table does not exist - NoSuchNamespaceException, the namespace does not exist
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type FetchPlanningResultError = FetchPlanningResultErrors[keyof FetchPlanningResultErrors];

export type FetchPlanningResultResponses = {
  /**
   * Result of fetching a submitted scan planning operation
   */
  200: FetchPlanningResult;
};

export type FetchPlanningResultResponse =
  FetchPlanningResultResponses[keyof FetchPlanningResultResponses];

export type FetchScanTasksData = {
  body?: FetchScanTasksRequest;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}/tasks';
};

export type FetchScanTasksErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchPlanTaskException, the plan-task does not exist - NoSuchTableException, the table does not exist - NoSuchNamespaceException, the namespace does not exist
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type FetchScanTasksError = FetchScanTasksErrors[keyof FetchScanTasksErrors];

export type FetchScanTasksResponses = {
  /**
   * Result of retrieving additional plan tasks and file scan tasks.
   */
  200: FetchScanTasksResult;
};

export type FetchScanTasksResponse = FetchScanTasksResponses[keyof FetchScanTasksResponses];

export type RegisterTableData = {
  body: RegisterTableRequest;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/register';
};

export type RegisterTableErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - The namespace specified does not exist
   */
  404: IcebergErrorResponse;
  /**
   * Conflict - The table already exists
   */
  409: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type RegisterTableError = RegisterTableErrors[keyof RegisterTableErrors];

export type RegisterTableResponses = {
  /**
   * Table metadata result when loading a table
   */
  200: LoadTableResultReadable;
};

export type RegisterTableResponse = RegisterTableResponses[keyof RegisterTableResponses];

export type DropTableData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
  };
  query?: {
    /**
     * Whether the user requested to purge the underlying table's data and metadata
     */
    purgeRequested?: boolean;
    /**
     * If true, ignore `protection-status` when dropping.
     */
    force?: boolean;
  };
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}';
};

export type DropTableErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, Table to drop does not exist
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type DropTableError = DropTableErrors[keyof DropTableErrors];

export type DropTableResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type DropTableResponse = DropTableResponses[keyof DropTableResponses];

export type LoadTableData = {
  body?: never;
  headers?: {
    /**
     * Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
     * Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
     * The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
     *
     */
    'X-Iceberg-Access-Delegation'?: 'vended-credentials' | 'remote-signing';
    /**
     * An optional header that allows the server to return 304 (Not Modified) if the metadata is current. The content is the value of the ETag received in a CreateTableResponse or LoadTableResponse.
     */
    'If-None-Match'?: string;
  };
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
  };
  query?: {
    /**
     * The snapshots to return in the body of the metadata. Setting the value to `all` would return the full set of snapshots currently valid for the table. Setting the value to `refs` would load all snapshots referenced by branches or tags.
     * Default if no param is provided is `all`.
     */
    snapshots?: 'all' | 'refs';
  };
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}';
};

export type LoadTableErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, table to load does not exist
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type LoadTableError = LoadTableErrors[keyof LoadTableErrors];

export type LoadTableResponses = {
  /**
   * Table metadata result when loading a table
   */
  200: LoadTableResultReadable;
};

export type LoadTableResponse = LoadTableResponses[keyof LoadTableResponses];

export type TableExistsData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}';
};

export type TableExistsErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, Table not found
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type TableExistsError = TableExistsErrors[keyof TableExistsErrors];

export type TableExistsResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type TableExistsResponse = TableExistsResponses[keyof TableExistsResponses];

export type UpdateTableData = {
  body: CommitTableRequestWritable;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}';
};

export type UpdateTableErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, table to load does not exist
   */
  404: IcebergErrorResponse;
  /**
   * Conflict - CommitFailedException, one or more requirements failed. The client may retry.
   */
  409: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * An unknown server-side problem occurred; the commit state is unknown.
   */
  500: IcebergErrorResponse;
  /**
   * A gateway or proxy received an invalid response from the upstream server; the commit state is unknown.
   */
  502: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side gateway timeout occurred; the commit state is unknown.
   */
  504: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable on the client.
   */
  '5XX': IcebergErrorResponse;
};

export type UpdateTableError = UpdateTableErrors[keyof UpdateTableErrors];

export type UpdateTableResponses = {
  /**
   * Response used when a table is successfully updated.
   * The table metadata JSON is returned in the metadata field. The corresponding file location of table metadata must be returned in the metadata-location field. Clients can check whether metadata has changed by comparing metadata locations.
   */
  200: CommitTableResponseReadable;
};

export type UpdateTableResponse = UpdateTableResponses[keyof UpdateTableResponses];

export type LoadCredentialsData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}/credentials';
};

export type LoadCredentialsErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, table to load credentials for does not exist
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type LoadCredentialsError = LoadCredentialsErrors[keyof LoadCredentialsErrors];

export type LoadCredentialsResponses = {
  /**
   * Table credentials result when loading credentials for a table
   */
  200: LoadCredentialsResponse;
};

export type LoadCredentialsResponse2 = LoadCredentialsResponses[keyof LoadCredentialsResponses];

export type RenameTableData = {
  /**
   * Current table identifier to rename and new table identifier to rename to
   */
  body: RenameTableRequest;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
  };
  query?: never;
  url: '/v1/{prefix}/tables/rename';
};

export type RenameTableErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, Table to rename does not exist - NoSuchNamespaceException, The target namespace of the new table identifier does not exist
   */
  404: IcebergErrorResponse;
  /**
   * Not Acceptable / Unsupported Operation. The server does not support this operation.
   */
  406: ErrorModel;
  /**
   * Conflict - The target identifier to rename to already exists as a table or view
   */
  409: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type RenameTableError = RenameTableErrors[keyof RenameTableErrors];

export type RenameTableResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type RenameTableResponse = RenameTableResponses[keyof RenameTableResponses];

export type ReportMetricsData = {
  /**
   * The request containing the metrics report to be sent
   */
  body: ReportMetricsRequest;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A table name
     */
    table: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/tables/{table}/metrics';
};

export type ReportMetricsErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, table to load does not exist
   */
  404: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type ReportMetricsError = ReportMetricsErrors[keyof ReportMetricsErrors];

export type ReportMetricsResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type ReportMetricsResponse = ReportMetricsResponses[keyof ReportMetricsResponses];

export type CommitTransactionData = {
  /**
   * Commit updates to multiple tables in an atomic operation
   *
   * A commit for a single table consists of a table identifier with requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, `assert-ref-snapshot-id` will check that a named ref's snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received.
   * Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.
   */
  body: CommitTransactionRequestWritable;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
  };
  query?: never;
  url: '/v1/{prefix}/transactions/commit';
};

export type CommitTransactionErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchTableException, table to load does not exist
   */
  404: IcebergErrorResponse;
  /**
   * Conflict - CommitFailedException, one or more requirements failed. The client may retry.
   */
  409: IcebergErrorResponse;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * An unknown server-side problem occurred; the commit state is unknown.
   */
  500: IcebergErrorResponse;
  /**
   * A gateway or proxy received an invalid response from the upstream server; the commit state is unknown.
   */
  502: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side gateway timeout occurred; the commit state is unknown.
   */
  504: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable on the client.
   */
  '5XX': IcebergErrorResponse;
};

export type CommitTransactionError = CommitTransactionErrors[keyof CommitTransactionErrors];

export type CommitTransactionResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type CommitTransactionResponse =
  CommitTransactionResponses[keyof CommitTransactionResponses];

export type ListViewsData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
  };
  query?: {
    pageToken?: PageToken;
    /**
     * For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
     */
    pageSize?: number;
    /**
     * If true, include the `table-uuids` field in the response
     */
    returnUuids?: boolean;
    /**
     * If true, include the `protection-status` field in the response
     */
    returnProtectionStatus?: boolean;
  };
  url: '/v1/{prefix}/namespaces/{namespace}/views';
};

export type ListViewsErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - The namespace specified does not exist
   */
  404: ErrorModel;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type ListViewsError = ListViewsErrors[keyof ListViewsErrors];

export type ListViewsResponses = {
  /**
   * A list of table identifiers
   */
  200: ListTablesResponse;
};

export type ListViewsResponse = ListViewsResponses[keyof ListViewsResponses];

export type CreateViewData = {
  body: CreateViewRequestWritable;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/views';
};

export type CreateViewErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - The namespace specified does not exist
   */
  404: ErrorModel;
  /**
   * Conflict - The view already exists
   */
  409: ErrorModel;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type CreateViewError = CreateViewErrors[keyof CreateViewErrors];

export type CreateViewResponses = {
  /**
   * View metadata result when loading a view
   */
  200: LoadViewResultReadable;
};

export type CreateViewResponse = CreateViewResponses[keyof CreateViewResponses];

export type DropViewData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A view name
     */
    view: string;
  };
  query?: {
    /**
     * If true, ignore `protection-status` when dropping.
     */
    force?: boolean;
  };
  url: '/v1/{prefix}/namespaces/{namespace}/views/{view}';
};

export type DropViewErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchViewException, view to drop does not exist
   */
  404: ErrorModel;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type DropViewError = DropViewErrors[keyof DropViewErrors];

export type DropViewResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type DropViewResponse = DropViewResponses[keyof DropViewResponses];

export type LoadViewData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A view name
     */
    view: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/views/{view}';
};

export type LoadViewErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchViewException, view to load does not exist
   */
  404: ErrorModel;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type LoadViewError = LoadViewErrors[keyof LoadViewErrors];

export type LoadViewResponses = {
  /**
   * View metadata result when loading a view
   */
  200: LoadViewResultReadable;
};

export type LoadViewResponse = LoadViewResponses[keyof LoadViewResponses];

export type ViewExistsData = {
  body?: never;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A view name
     */
    view: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/views/{view}';
};

export type ViewExistsErrors = {
  /**
   * Bad Request
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Not Found
   */
  404: unknown;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type ViewExistsError = ViewExistsErrors[keyof ViewExistsErrors];

export type ViewExistsResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type ViewExistsResponse = ViewExistsResponses[keyof ViewExistsResponses];

export type ReplaceViewData = {
  body: CommitViewRequestWritable;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
    /**
     * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
     */
    namespace: string;
    /**
     * A view name
     */
    view: string;
  };
  query?: never;
  url: '/v1/{prefix}/namespaces/{namespace}/views/{view}';
};

export type ReplaceViewErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchViewException, view to load does not exist
   */
  404: ErrorModel;
  /**
   * Conflict - CommitFailedException. The client may retry.
   */
  409: ErrorModel;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * An unknown server-side problem occurred; the commit state is unknown.
   */
  500: ErrorModel;
  /**
   * A gateway or proxy received an invalid response from the upstream server; the commit state is unknown.
   */
  502: ErrorModel;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side gateway timeout occurred; the commit state is unknown.
   */
  504: ErrorModel;
  /**
   * A server-side problem that might not be addressable on the client.
   */
  '5XX': ErrorModel;
};

export type ReplaceViewError = ReplaceViewErrors[keyof ReplaceViewErrors];

export type ReplaceViewResponses = {
  /**
   * View metadata result when loading a view
   */
  200: LoadViewResultReadable;
};

export type ReplaceViewResponse = ReplaceViewResponses[keyof ReplaceViewResponses];

export type RenameViewData = {
  /**
   * Current view identifier to rename and new view identifier to rename to
   */
  body: RenameTableRequest;
  path: {
    /**
     * An optional prefix in the path
     */
    prefix: string;
  };
  query?: never;
  url: '/v1/{prefix}/views/rename';
};

export type RenameViewErrors = {
  /**
   * Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure, such as invalid json. Usually serves application/json content, although in some cases simple text/plain content might be returned by the server's middleware.
   */
  400: IcebergErrorResponse;
  /**
   * Unauthorized. The REST Catalog SHOULD respond with the 401 UnauthorizedResponse when the access token provided is expired, revoked, malformed, or invalid for other reasons. The client MAY request a new access token and retry the request.
   */
  401: IcebergErrorResponse;
  /**
   * Forbidden. Authenticated user does not have the necessary permissions.
   */
  403: IcebergErrorResponse;
  /**
   * Not Found - NoSuchViewException, view to rename does not exist - NoSuchNamespaceException, The target namespace of the new identifier does not exist
   */
  404: ErrorModel;
  /**
   * Not Acceptable / Unsupported Operation. The server does not support this operation.
   */
  406: ErrorModel;
  /**
   * Conflict - The target identifier to rename to already exists as a table or view
   */
  409: ErrorModel;
  /**
   * This is an optional status response type that the REST Catalog can issue when the token has expired. The client MAY request a new access token and retry the request. 401 UnauthorizedResponse SHOULD be preferred over this response type on token expiry.
   */
  419: IcebergErrorResponse;
  /**
   * The service is not ready to handle the request, request could have been partially processed.
   * The service may additionally send a Retry-After header to indicate when to retry, a non idempotent request should only be retried by the client when the Retry-After header is present.
   */
  503: IcebergErrorResponse;
  /**
   * A server-side problem that might not be addressable from the client side. Used for server 5xx errors without more specific documentation in individual routes.
   */
  '5XX': IcebergErrorResponse;
};

export type RenameViewError = RenameViewErrors[keyof RenameViewErrors];

export type RenameViewResponses = {
  /**
   * Success, no content
   */
  204: void;
};

export type RenameViewResponse = RenameViewResponses[keyof RenameViewResponses];

export type ClientOptions = {
  baseUrl: '{scheme}://{host}/{basePath}' | '{scheme}://{host}:{port}/{basePath}' | (string & {});
};
